---
package: "@quen-ui/components"
title: RadioButton
order: 1
group: "components"
description: "A single selectable radio button with label support. Used for exclusive selection in forms and interfaces."
import: "import { RadioButton, RadioButtonGroup } from '@quen-ui/components';"
source: "/packages/components/src/RadioButton"
excludeDemoProps: ["value"]
props: ["RadioButton", "RadioButtonGroup"]
---

import { RadioButton, Flex } from "@quen-ui/components";
import { LanguageSelect } from "../../examples/RadioButton";

#### Basic usage

##### Single RadioButton

A standalone `RadioButton` can be used for binary choices (e.g., accept/decline).

<RadioButton label="Accept terms" name="agreement" value="accept" />

```tsx
function Demo() {
  return <RadioButton label="Accept terms" name="agreement" value="accept" />;
}
```

##### Basic RadioButton.Group

`RadioButton.Group` is the preferred way to render a set of related options.

<RadioButton.Group
  label="Notification method"
  options={[
    { label: "Email", value: "email" },
    { label: "SMS", value: "sms" },
    { label: "Push", value: "push", disabled: true }
  ]}
  direction="horizontal"
/>

```tsx
const options = [
  { label: "Email", value: "email" },
  { label: "SMS", value: "sms" },
  { label: "Push", value: "push", disabled: true }
];

function Demo() {
  return (
    <RadioButton.Group
      label="Notification method"
      options={options}
      direction="horizontal"
    />
  );
}
```

#### States demonstration

Showcases all available states:

<Flex gap={8}>
  <RadioButton label="Unchecked" />
  <RadioButton isChecked label="Checked" />
  <RadioButton disabled label="Disabled" />
  <RadioButton disabled isChecked label="Disabled checked" />
</Flex>

```tsx
<Flex gap={8}>
  <RadioButton label="Unchecked" />
  <RadioButton isChecked label="Checked" />
  <RadioButton disabled label="Disabled" />
  <RadioButton disabled isChecked label="Disabled checked" />
</Flex>
```

#### Size variants

Supports QuenUI sizing tokens (`xs`, `s`, `m`, `l`).

<Flex gap={8} direction="column">
  <RadioButton label="XS" size="xs" />
  <RadioButton label="S" size="s" />
  <RadioButton label="M" size="m" />
  <RadioButton label="L" size="l" />
</Flex>

```tsx
<Flex gap={8} direction="column">
  <RadioButton label="XS" size="xs" />
  <RadioButton label="S" size="s" />
  <RadioButton label="M" size="m" />
  <RadioButton label="L" size="l" />
</Flex>
```


#### Advanced example

Custom rendering with icons, disabled states, and horizontal layout.

<LanguageSelect />

```tsx
const complexOptions = [
  { code: "en", title: "English", icon: <IconFlag /> },
  { code: "fr", title: "French", disabled: true }
];

export const LanguageSelect = () => {
  return (
    <RadioButton.Group
      options={complexOptions}
      direction="horizontal"
      getItemValue={(item) => item.code}
      getItemLabel={(item) => (
       <Flex align="center">
          {item.icon}
          <span>{item.title}</span>
        </Flex>
      )}
      getItemDisabled={(item) => item.disabled}
    />
  );
}
```

#### Best practices

##### When to use

  - Single choice from a set — when only one option is valid
  - Binary choices — e.g., agree/disagree, yes/no
  - Grouped preferences — lists of 3–7 options with clear labels

##### When not to use

  - Avoid for multi-select scenarios (use Checkbox instead)
  - Avoid long lists (prefer Select dropdown)
  - Avoid ambiguous labels (always explain what each choice means)

#### Design & UX guidelines

  - Use horizontal layout for up to 3 options, vertical layout for longer lists
  - Keep labels short and descriptive
  - Provide disabled states for unavailable options
  - Ensure groups have a clear label describing the decision
